---
title: "三样本profast"
author: "yws"
date: "2024-03-18"
output: html_document
---


```{r}
library(parallel)
library(ProFAST) # load the package of FAST method
library(PRECAST)
library(Seurat)
library(SeuratDisk)
library(Matrix)
library(stringr)
library(irlba)
setwd('./data/hippo')
```

# profast
```{r}
start_time <- proc.time()
data_slice1_X=read.csv('data_slice1_X.csv',row.names=1)
data_slice2_X=read.csv('data_slice2_X.csv',row.names=1)
data_slice3_X=read.csv('data_slice3_X.csv',row.names=1)
data_slice1_spatial=read.csv('data_slice1_spatial.csv',header = FALSE)
data_slice2_spatial=read.csv('data_slice2_spatial.csv',header = FALSE)
data_slice3_spatial=read.csv('data_slice3_spatial.csv',header = FALSE)
```

```{r}
data_slice1_X=as.matrix(data_slice1_X)
data_slice2_X=as.matrix(data_slice2_X)
data_slice3_X=as.matrix(data_slice3_X)
data_slice1_X=as(data_slice1_X,"sparseMatrix")
data_slice2_X=as(data_slice2_X,"sparseMatrix")
data_slice3_X=as(data_slice3_X,"sparseMatrix")
```

```{r}
data_slice1=CreateSeuratObject(counts=t(data_slice1_X))
data_slice2=CreateSeuratObject(counts=t(data_slice2_X))
data_slice3=CreateSeuratObject(counts=t(data_slice3_X))
```


```{r}
data_slice1@meta.data[["row"]]=data_slice1_spatial[,1]
data_slice1@meta.data[["col"]]=data_slice1_spatial[,2]

data_slice2@meta.data[["row"]]=data_slice2_spatial[,1]
data_slice2@meta.data[["col"]]=data_slice2_spatial[,2]

data_slice3@meta.data[["row"]]=data_slice3_spatial[,1]
data_slice3@meta.data[["col"]]=data_slice3_spatial[,2]
```

```{r}
data_slice1=SCTransform(data_slice1, assay = "RNA",  verbose = FALSE) 
data_slice2=SCTransform(data_slice2, assay = "RNA",  verbose = FALSE)
data_slice3=SCTransform(data_slice3, assay = "RNA",  verbose = FALSE)
```


```{r}
data= list(data_slice1,data_slice2,data_slice3)
data
```

```{r}
## Get the gene-by-spot read count matrices
countList1 <- lapply(data, function(x) x[["SCT"]]@counts)

## Check the spatial coordinates: Yes, they are named as "row" and "col"!
head(data[[1]]@meta.data)

## Get the meta data of each spot for each data batch
metadataList1 <- lapply(data, function(x) x@meta.data)


## ensure the row.names of metadata in metaList are the same as that of colnames count matrix in countList
M1 <- length(countList1)
for(r in 1:M1){
  row.names(metadataList1[[r]]) <- colnames(countList1[[r]])
}


## Create the Seurat list  object

seuList1 <- list()
for(r in 1:M1){
  seuList1[[r]] <- CreateSeuratObject(counts = countList1[[r]], meta.data=metadataList1[[r]], project = "FASTdata")
}
```

```{r}

## Create PRECASTObject
custom_genelist1 <- row.names(seuList1[[1]])
set.seed(2023)
PRECASTObj1 <-  CreatePRECASTObject(seuList1, customGenelist=custom_genelist1,premin.spots =0,premin.features=0,postmin.spots=0,postmin.features=0)

## User can retain the raw seuList by the following commond.
##  PRECASTObj <-  CreatePRECASTObject(seuList, customGenelist=row.names(seuList[[1]]), rawData.preserve = TRUE)
## check the number of genes/features after filtering step
PRECASTObj1@seulist
```

```{r}

## seuList is null since the default value `rawData.preserve` is FALSE.
PRECASTObj1@seuList

## Add adjacency matrix list for a PRECASTObj object to prepare for FAST model fitting.
PRECASTObj1 <- AddAdjList(PRECASTObj1, platform = "ST")

## Add a model setting in advance for a PRECASTObj object: verbose =TRUE helps outputing the information in the algorithm; 
PRECASTObj1 <- AddParSettingFAST(PRECASTObj1, verbose=TRUE)
## Check the parameters
PRECASTObj1@parameterList
```

```{r}
q = 256
fit.model = "gaussian"
para_names <- c("maxIter", "epsLogLik", "verbose", "error_heter", "Psi_diag", "seed")
fit.model <- match.arg(fit.model,'gaussian')
verbose <- PRECASTObj1@parameterList$verbose
message("******", "Run the Gaussian version of FAST...")

get_data <- function(seu_obj, assay = NULL, fit.model = "gaussian") {
  if (is.null(assay)) 
    assay <- DefaultAssay(seu_obj)
  
  if (fit.model == "poisson") {
    dat <- GetAssayData(seu_obj, assay = assay, layer = "counts")
  } else if (fit.model == "gaussian") {
    dat <- GetAssayData(seu_obj, assay = assay, layer = "data")
  } else {
    stop("FAST: Check the argument: fit.model! It is not supported for this fit.model!")
  }
  
  return(Matrix::t(as.matrix(dat)))  # 转置并确保是矩阵格式
}
XList1 <- lapply(PRECASTObj1@seulist, get_data, fit.model = fit.model)#报错

PRECASTObj1@resList$FAST <- FAST_structure(XList1, q = 256, fit.model = fit.model, AdjList = PRECASTObj1@AdjList, parameterList = PRECASTObj1@parameterList)
```

```{r}
PRECASTObj=PRECASTObj1
```

```{r}
embedding1=t(PRECASTObj1@resList[["FAST"]][["hV"]][[1]])
embedding2=t(PRECASTObj1@resList[["FAST"]][["hV"]][[2]])
embedding3=t(PRECASTObj1@resList[["FAST"]][["hV"]][[3]])
```

```{r}
spatial1=matrix(c(PRECASTObj1@seulist[[1]]@meta.data[["row"]],PRECASTObj1@seulist[[1]]@meta.data[["col"]]),ncol=2)
spatial2=matrix(c(PRECASTObj1@seulist[[2]]@meta.data[["row"]],PRECASTObj1@seulist[[2]]@meta.data[["col"]]),ncol=2)
spatial3=matrix(c(PRECASTObj1@seulist[[3]]@meta.data[["row"]],PRECASTObj1@seulist[[3]]@meta.data[["col"]]),ncol=2)
```


```{r}
write.csv(embedding1,'embedding1.csv',row.names=F)
write.csv(embedding2,'embedding2.csv',row.names=F)
write.csv(embedding3,'embedding3.csv',row.names=F)
```

```{r}
end_time <- proc.time()
run_time <- end_time - start_time

print(run_time)
```

